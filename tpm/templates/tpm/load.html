<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://unpkg.com/mathjs@10.1.1/lib/browser/math.js"></script>
    <title>Document</title>
    <style type="text/css">
        .weights {
            margin-left: 20px;
        }
        .row { 
            display: block;
            /* width: 250px; */
            /* height: 30px; */
            font-size: 120%; /* Размер шрифта */
            font-family: Verdana, Arial, Helvetica, sans-serif; /* Семейство шрифта */
            color: rgb(198, 198, 221); /* Цвет текста */
        }
        .block {
            text-align: center;
            display: inline-block;
            max-width: 70px;
            padding: 8px;
            border: 1px solid #222222;
        }
        .red {
            background-color: red;
        }
        .green {
            background-color: rgb(74, 206, 74);
        }
    </style>
</head>
<body>
    <h1>Веса</h1>
    <div class="weights"></div>
    <!-- <form id="form">
        <input type="text" name="message">
    </form>

    <div id="messages"></div>
    <button onclick="cl()">click</button> -->

    <script type="text/javascript">
        let url = `ws://${window.location.host}/ws/socket-server/`
        const elem = document.querySelector('.weights');
        let config = ''
        function cl(){
            console.log('ttt')
        }
        class Machine {
            constructor(k_=3, n_=4, l_=6) {
                this.k = k_;
                this.n = n_;
                this.l = l_;
                let dim = [this.k,this.n]
                this.W = math.randomInt(dim, -this.l, this.l)
            }
            get_output(X) {
                // Returns a binary digit tau for a given random vecor.
                // Arguments:
                // X - Input random vector
                let mult = [];
                let sigma = [];
                let tau = 1;
                for(let i = 0; i < this.k; i++){
                    mult[i] = [];
                    for(let j = 0; j < this.n; j++){
                        mult[i][j] = X[i][j] * this.W[i][j];
                    }
                    sigma[i] =  this.g(math.sum(mult[i]));
                    tau *= sigma[i];
                }
                this.X = X;
                this.sigma = sigma;
                this.tau = tau;
                // for (let i = 0; i < this.k; i++) {
                //     this.H[i] = this.signum(math.multiply(input_[i], this.weights[i]))
                //     this.out = this.out * this.signum(math.multiply(input_[i], this.weights[i])) 
                // }
                return tau
            }
            g(a) {
                if (a < 0) {
                    return -1.0;
                } else {
                    if (a>0){
                        return 1.0;
                    }
                    else{
                        return 0.0
                    }
                }
            }
            Interval(w) {
                if (w > this.l) {
                return this.l;
                }
                if (w < -this.l) {
                return -this.l;
                } else {
                return w;
                }
            }
            update(tau2, X, update_rule='hebbian', W){
                // Updates the weights according to the specified update rule.

                // Arguments:
                // tau2 - Output bit from the other machine;

                // update_rule - The update rule. 
                // Should be one of ['hebbian', 'anti_hebbian', random_walk']
                if (this.tau == tau2){
                    if(update_rule == 'hebbian'){
                        // console.log(this.W)
                        for(let i = 0; i < this.W.length; i++){
                            for(let j = 0; j < this.W[i].length; j++){
                                this.W[i][j] += X[i][j] * this.tau * this.theta(this.sigma[i], this.tau) * this.theta(this.tau, tau2);
                                this.W[i][j] = this.Interval(this.W[i][j]);
                            }
                        }
                        // console.log(this.W)
                    } else{
                        if(update_rule == 'anti_hebbian'){
                            this.anti_hebbian(this.W, this.X, this.sigma, this.tau, tau2)
                        } else{
                            if(update_rule == 'random_walk'){
                                this.random_walk(this.W, this.X, this.sigma, this.tau, tau2)
                            }
                        }
                    }
                }
                elem.innerHTML = '';
                for (let i = 0; i < this.W.length; i++) {
                    const element = this.W[i];
                    let $newrow = document.createElement('div');
                    $newrow.className = 'row';
                    for (let j = 0; j < this.W[i].length; j++) {
                        const element = this.W[i][j];
                        let weight = document.createElement('span');
                        if(W[i][j] == this.W[i][j]){
                            weight.className = 'block green';
                        } 
                        else{
                            weight.className = 'block red';
                        }
                        weight.innerHTML = `${this.W[i][j]}`;
                        $newrow.appendChild(weight);
                    }
                    elem.appendChild($newrow);
                }
                console.log(1111, elem);
                // let $newrow = document.createElement('.row');
                // let weight = document.createElement('span.block');
                // weight.innerHTML = `${this.W}`;
                // $newrow.appendChild(weight);
                // elem.innerHTML = '';
                // elem.innerHTML = `${this.W}`;
                // setTimeout(() => {  console.log("World!"); }, 1000);
            }
            theta(t1, t2){
                return (parseInt(t1) == parseInt(t2)) ? 1 : 0;
            }
            hebbian(W, X, sigma, tau1, tau2){
                for(let i = 0; i < W.lenght; i++){
                    for(let j = 0; j < W[i].lenght; j++){
                        this.W[i][j] += X[i][j] * tau1 * this.theta(sigma[i], tau1) * this.theta(tau1, tau2);
                        this.W[i][j] = this.Interval(this.W[i][j]);
                    }
                }
            }
            anti_hebbian(W, X, sigma, tau1, tau2){
                for(let i = 0; i < W.lenght; i++){
                    for(let j = 0; j < W[i].lenght; j++){
                        this.W[i][j] -= X[i][j] * tau1 * this.theta(sigma[i], tau1) * this.theta(tau1, tau2);
                        this.W[i][j] = this.Interval(this.W[i][j]);
                    }
                }
            }
            random_walk(W, X, sigma, tau1, tau2){
                for(let i = 0; i < W.lenght; i++){
                    for(let j = 0; j < W[i].lenght; j++){
                        this.W[i][j] += X[i][j] * this.theta(sigma[i], tau1) * this.theta(tau1, tau2);
                        this.W[i][j] = this.Interval(this.W[i][j]);
                    }
                }
            }
            chaosmap() {
                let r = math.sum(this.W)
                let rr = math.sum(math.abs(this.W))
                let t = math.abs(r) / rr;
                let x = t;
                for (let i = 0; i < rr; i++) {
                x = (3.6 + t/2)* x *(1 - x)
                }
                return x
            }
        }

        function gen_rand_vector(sid, l, k, n){
            config = {
                epsilon: 1e-12,
                matrix: 'Matrix',
                number: 'number',
                precision: 64,
                predictable: false,
                randomSeed: sid
            }
            math = math.create(math.all, config)
            dim = [k,n]
            //console.log(sid, math.randomInt(dim, -l, l) )
            return math.randomInt(dim, -l, l) 
        } //сид, диапазон, количество нейронов, количество входов

        const delay = ms => new Promise(res => setTimeout(res, ms));

        let k = 8
        let n = 8
        let l = 100

        function start(websocketServerLocation){
            tpmSocket = new WebSocket(websocketServerLocation);

            let ClientTPM = new Machine()

            tpmSocket.onopen = (()=>{
                console.log("Connected to server")
                //ClientTPM = new Machine()
                tpmSocket.send(JSON.stringify({
                    'type': 'ClientReadySync',
                    'message': 'client connected',
                }));
                    // tpmSocket.send(JSON.stringify({
                    //     'type': 'join',
                    //     'channel': CHANNEL,
                    // }))
            })

            tpmSocket.onmessage = function(e){
                let data = JSON.parse(e.data)
                //console.log('Data:', data)
                if(data.type === 'chat'){
                    let messages = document.getElementById('messages')

                    messages.insertAdjacentHTML('beforeend', `<div>
                                                <p>${data.message}</p>
                                            </div>`)

                }
                if(data.type === 'receive_chaos_output2'){
                    if (data.output == tpmclient.tpm.chaosmap()){
                        tpmclient.IsSync = True
                        console.log('SUCCESS: synched with Bob')
                        tpmSocket.CLOSED()
                        tpmclient.save_key()
                    }
                }
                if(data.type === 'ServerReadySync'){
                    //console.log(`ServerReadySync msg:${data.message}`)
                    ClientTPM = new Machine(k, n, l)
                    tpmSocket.send(JSON.stringify({
                        'type': 'GetParametrs',
                        'message':'Give paremetrs of machine to server',
                        'k': ClientTPM.k,
                        'n': ClientTPM.n,
                        'l': ClientTPM.l
                    }));
                }
                if(data.type === 'GetFirstSid'){
                    //console.log(`ServerReadySync msg:${data.message}`)
                    // console.log("sid:",data['sid'])
                    let X = data['vector']//gen_rand_vector(data['sid'], ClientTPM.l, ClientTPM.k, ClientTPM.n)
                    // console.log("Vector:",X)
                    let resultClient = ClientTPM.get_output(X)
                    // console.log("resultClient:",resultClient)
                    // console.log("=================");
                    tpmSocket.send(JSON.stringify({
                        'type': 'GetResultClient',
                        'resultClient':resultClient,
                        'chaosmap': ClientTPM.chaosmap(),
                        'W': ClientTPM.W
                    }));
                }
                if(data.type === 'GetSidAndResultTrue'){
                    //console.log(ClientTPM)
                    let X = data['vector']//(data["sid"], l, k, n);
                    console.log(ClientTPM.W)
                    console.log(ClientTPM.chaosmap())
                    // setTimeout(() => {ClientTPM.update(data["Result"],X, 'hebbian'); }, 0);
                    ClientTPM.update(data["Result"],X, 'hebbian', data['W']);
                    let resultClient =  ClientTPM.get_output(X);
                        tpmSocket.send(JSON.stringify({
                            'type': 'GetResultClient',
                            'resultClient':resultClient,
                            'chaosmap': ClientTPM.chaosmap(),
                            'W': ClientTPM.W
                    }));
                }
                if(data.type === 'GetSidAndResultFalse'){
                    //console.log(`output_received msg:${data.message}`)
                    let X = data['vector']//gen_rand_vector(data["sid"], l, k, n);
                    let resultClient =  ClientTPM.get_output(X);
                    tpmSocket.send(JSON.stringify({
                        'type': 'GetResultClient',
                        'resultClient':resultClient,
                        'chaosmap': ClientTPM.chaosmap(),
                        'W': ClientTPM.W
                    }));
                }
                if(data.type === 'FinishSync'){
                    console.log('FinishSync')
                    console.log(ClientTPM.W)
                    console.log(ClientTPM.chaosmap())
                    tpmSocket.close();
                }
                // if(data.type === 'Resync'){
                //     console.log('Reconnect');
                //     tpmSocket.send(JSON.stringify({
                //         'type': 'ClientReadySync',
                //         'message': 'client connected',
                //     }));
                // }
                // if(data.type === 'receive_chaos_output'){
                //     console.log(`receive_chaos_output msg:${data.message}`)
                //     tpmSocket.send(JSON.stringify({
                //         'type': 'confirm_chaos_output',
                //         'message':'sending chaos output',
                //         'output': tpmclient.tpm.chaosmap(),
                //     }));
                //     if (data.output == tpmclient.tpm.chaosmap()){
                //         tpmclient.IsSync = True;
                //         cosole.log('SUCCESS: synched with Alice');
                //         tpmSocket.disconnect();
                //     }
                // }
                // if(data.type === 'chat'){}
            }

            // ws.onmessage = function(evt) { alert('message received'); };
            tpmSocket.onclose = function(){
                // Try to reconnect in 5 seconds
                setTimeout(function(){start(websocketServerLocation)}, 35000);
            };
        }

        start(url)


        console.log('end')

    </script>
</body>
</html>
