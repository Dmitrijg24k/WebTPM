<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://unpkg.com/mathjs@10.1.1/lib/browser/math.js"></script>
    <title>Document</title>
    <style type="text/css">
        .weights {
            margin-left: 20px;
        }
        .row { 
            display: block;
            /* width: 250px; */
            /* height: 30px; */
            font-size: 120%; /* Размер шрифта */
            font-family: Verdana, Arial, Helvetica, sans-serif; /* Семейство шрифта */
            color: rgb(198, 198, 221); /* Цвет текста */
        }
        .block {
            text-align: center;
            display: inline-block;
            max-width: 70px;
            padding: 8px;
            border: 1px solid #222222;
        }
        .red {
            background-color: red;
        }
        .green {
            background-color: rgb(74, 206, 74);
        }
    </style>
</head>
<body>
    <h1>Веса</h1>
    <div class="weights"></div>
    <!-- <form id="form">
        <input type="text" name="message">
    </form>

    <div id="messages"></div>
    <button onclick="cl()">click</button> -->

    <script type="text/javascript">
        let url = `ws://${window.location.host}/ws/socket-server/`
        const elem = document.querySelector('.weights');
        let config = ''
        function cl(){
            console.log('ttt')
        }
        class Machine {
            constructor(k_=3, n_=4, l_=6) {
                this.k = k_;
                this.n = n_;
                this.l = l_;
                let dim = [this.k,this.n]
                this.W = math.randomInt(dim, -this.l, this.l)
            }
            get_output(X) {
                // Returns a binary digit tau for a given random vecor.
                // Arguments:
                // X - Input random vector
                let mult = [];
                let sigma = [];
                let tau = 1;
                for(let i = 0; i < this.k; i++){
                    mult[i] = [];
                    for(let j = 0; j < this.n; j++){
                        mult[i][j] = X[i][j] * this.W[i][j];
                    }
                    sigma[i] =  this.g(math.sum(mult[i]));
                    tau *= sigma[i];
                }
                this.X = X;
                this.sigma = sigma;
                this.tau = tau;
                // for (let i = 0; i < this.k; i++) {
                //     this.H[i] = this.signum(math.multiply(input_[i], this.weights[i]))
                //     this.out = this.out * this.signum(math.multiply(input_[i], this.weights[i])) 
                // }
                return tau
            }
            g(a) {
                if (a < 0) {
                    return -1.0;
                } else {
                    if (a>0){
                        return 1.0;
                    }
                    else{
                        return 0.0
                    }
                }
            }
            Interval(w) {
                if (w > this.l) {
                return this.l;
                }
                if (w < -this.l) {
                return -this.l;
                } else {
                return w;
                }
            }
            update(tau2, X, update_rule='hebbian', W){
                // Updates the weights according to the specified update rule.

                // Arguments:
                // tau2 - Output bit from the other machine;

                // update_rule - The update rule. 
                // Should be one of ['hebbian', 'anti_hebbian', random_walk']
                if (this.tau == tau2){
                    if(update_rule == 'hebbian'){
                        // console.log(this.W)
                        for(let i = 0; i < this.W.length; i++){
                            for(let j = 0; j < this.W[i].length; j++){
                                this.W[i][j] += X[i][j] * this.tau * this.theta(this.sigma[i], this.tau) * this.theta(this.tau, tau2);
                                this.W[i][j] = this.Interval(this.W[i][j]);
                            }
                        }
                        // console.log(this.W)
                    } else{
                        if(update_rule == 'anti_hebbian'){
                            this.anti_hebbian(this.W, this.X, this.sigma, this.tau, tau2)
                        } else{
                            if(update_rule == 'random_walk'){
                                this.random_walk(this.W, this.X, this.sigma, this.tau, tau2)
                            }
                        }
                    }
                }
                elem.innerHTML = '';
                for (let i = 0; i < this.W.length; i++) {
                    const element = this.W[i];
                    let $newrow = document.createElement('div');
                    $newrow.className = 'row';
                    for (let j = 0; j < this.W[i].length; j++) {
                        const element = this.W[i][j];
                        let weight = document.createElement('span');
                        if(W[i][j] == this.W[i][j]){
                            weight.className = 'block green';
                        } 
                        else{
                            weight.className = 'block red';
                        }
                        weight.innerHTML = `${this.W[i][j]}`;
                        $newrow.appendChild(weight);
                    }
                    elem.appendChild($newrow);
                }
                console.log(1111, elem);
                // let $newrow = document.createElement('.row');
                // let weight = document.createElement('span.block');
                // weight.innerHTML = `${this.W}`;
                // $newrow.appendChild(weight);
                // elem.innerHTML = '';
                // elem.innerHTML = `${this.W}`;
                // setTimeout(() => {  console.log("World!"); }, 1000);
            }
            theta(t1, t2){
                return (parseInt(t1) == parseInt(t2)) ? 1 : 0;
            }
            hebbian(W, X, sigma, tau1, tau2){
                for(let i = 0; i < W.lenght; i++){
                    for(let j = 0; j < W[i].lenght; j++){
                        this.W[i][j] += X[i][j] * tau1 * this.theta(sigma[i], tau1) * this.theta(tau1, tau2);
                        this.W[i][j] = this.Interval(this.W[i][j]);
                    }
                }
            }
            anti_hebbian(W, X, sigma, tau1, tau2){
                for(let i = 0; i < W.lenght; i++){
                    for(let j = 0; j < W[i].lenght; j++){
                        this.W[i][j] -= X[i][j] * tau1 * this.theta(sigma[i], tau1) * this.theta(tau1, tau2);
                        this.W[i][j] = this.Interval(this.W[i][j]);
                    }
                }
            }
            random_walk(W, X, sigma, tau1, tau2){
                for(let i = 0; i < W.lenght; i++){
                    for(let j = 0; j < W[i].lenght; j++){
                        this.W[i][j] += X[i][j] * this.theta(sigma[i], tau1) * this.theta(tau1, tau2);
                        this.W[i][j] = this.Interval(this.W[i][j]);
                    }
                }
            }
            chaosmap() {
                let r = math.sum(this.W)
                let rr = math.sum(math.abs(this.W))
                let t = math.abs(r) / rr;
                let x = t;
                for (let i = 0; i < rr; i++) {
                x = (3.6 + t/2)* x *(1 - x)
                }
                return x
            }
        }

        function  MersenneTwister() {
            function Int32(value) {
                var bits = new Array(0, 0, 0, 0);
                var i;
                var v = value;
                if (v != 0) {
                    for (i = 0; i < 4; ++i) {
                    bits[i] = v & 0xff;
                    v = v >> 8;
                    }
                }
                this.getValue = function () {
                    return (bits[0] | (bits[1] << 8) | (bits[2] << 16)) + ((bits[3] << 16) * 0x100);
                };
                this.getBits = function (i) { return bits[i & 3]; };
                this.setBits = function (i, val) { return (bits[i & 3] = val & 0xff); };
                this.add = function (another) {
                    var tmp = new Int32(0);
                    var i, fl = 0, b;
                    for (i = 0; i < 4; ++i) {
                        b = bits[i] + another.getBits(i) + fl;
                        tmp.setBits(i, b);
                        fl = b >> 8;
                    }
                    return tmp;
                };
                this.sub = function (another) {
                    var tmp = new Int32(0);
                    var bb = new Array(0, 0, 0, 0);
                    var i;
                    for (i = 0; i < 4; ++i) {
                        bb[i] = bits[i] - another.getBits(i);
                        if ((i > 0) && (bb[i - 1] < 0)) {
                            --bb[i];
                        }
                    }
                    for (i = 0; i < 4; ++i) {
                        tmp.setBits(i, bb[i]);
                    }
                    return tmp;
                };
                this.mul = function (another) {
                    var tmp = new Int32(0);
                    var bb = new Array(0, 0, 0, 0, 0);
                    var i, j;
                    for (i = 0; i < 4; ++i) {
                        for (j = 0; i + j < 4; ++j) {
                            bb[i + j] += bits[i] * another.getBits(j);
                        }
                        tmp.setBits(i, bb[i]);
                        bb[i + 1] += bb[i] >> 8;
                    }
                    return tmp;
                };
                this.and = function (another) {
                    var tmp = new Int32(0);
                    var i;
                    for (i = 0; i < 4; ++i) {
                        tmp.setBits(i, bits[i] & another.getBits(i));
                    }
                    return tmp;
                };
                this.or = function (another) {
                    var tmp = new Int32(0);
                    var i;
                    for (i = 0; i < 4; ++i) {
                        tmp.setBits(i, bits[i] | another.getBits(i));
                    }
                    return tmp;
                };
                this.xor = function (another) {
                    var tmp = new Int32(0);
                    var i;
                    for (i = 0; i < 4; ++i) {
                        tmp.setBits(i, bits[i] ^ another.getBits(i));
                    }
                    return tmp;
                };
                this.rshifta = function (s) {
                    var tmp = new Int32(0);
                    var bb = new Array(0, 0, 0, 0, 0);
                    var p = s >> 3;
                    var i, sg = 0;
                    if ((bits[3] & 0x80) > 0) {
                        bb[4] = sg = 0xff;
                    }
                    for (i = 0; i + p < 4; ++i) {
                        bb[i] = bits[i + p];
                    }
                    for (; i < 4; ++i) {
                        bb[i] = sg;
                    }
                    p = s & 0x7;
                    for (i = 0; i < 4; ++i) {
                        tmp.setBits(i, ((bb[i] | (bb[i + 1] << 8)) >> p) & 0xff);
                    }
                    return tmp;
                };
                this.rshiftl = function (s) {
                    var tmp = new Int32(0);
                    var bb = new Array(0, 0, 0, 0, 0);
                    var p = s >> 3;
                    var i;
                    for (i = 0; i + p < 4; ++i) {
                        bb[i] = bits[i + p];
                    }
                    p = s & 0x7;
                    for (i = 0; i < 4; ++i) {
                        tmp.setBits(i, ((bb[i] | (bb[i + 1] << 8)) >> p) & 0xff);
                    }
                    return tmp;
                };
                this.lshift = function (s) {
                    var tmp = new Int32(0);
                    var bb = new Array(0, 0, 0, 0, 0);
                    var p = s >> 3;
                    var i;
                    for (i = 0; i + p < 4; ++i) {
                        bb[i + p + 1] = bits[i];
                    }
                    p = s & 0x7;
                    for (i = 0; i < 4; ++i) {
                        tmp.setBits(i, (((bb[i] | (bb[i + 1] << 8)) << p) >> 8) & 0xff);
                    }
                    return tmp;
                };
                this.equals = function (another) {
                    var i;
                    for (i = 0; i < 4; ++i) {
                        if (bits[i] != another.getBits(i)) {
                            return false;
                        }
                    }
                    return true;
                };
                this.compare = function (another) {
                    var i;
                    for (i = 3; i >= 0; --i) {
                        if (bits[i] > another.getBits(i)) {
                            return 1;
                        } else if (bits[i] < another.getBits(i)) {
                            return -1;
                        }
                    }
                    return 0;
                };
            }
            // End of Int32


            /* Period parameters */
            var N = 624;
            var M = 397;
            var MATRIX_A = new Int32(0x9908b0df); /* constant vector a */
            var UMASK = new Int32(0x80000000); /* most significant w-r bits */
            var LMASK = new Int32(0x7fffffff); /* least significant r bits */

            var INT32_ZERO = new Int32(0);
            var INT32_ONE = new Int32(1);

            var MIXBITS = function (u, v) {
                return (u.and(UMASK)).or(v.and(LMASK));
            };
            var TWIST = function (u, v) {
                return ((MIXBITS(u, v).rshiftl(1)).xor((v.and(INT32_ONE)).equals(INT32_ZERO) ? INT32_ZERO : MATRIX_A));
            };

            var state = new Array(); /* the array for the state vector  */
            var left = 1;
            var initf = 0;
            var next = 0;

            var i;
            for (i = 0; i < N; ++i) {
                state[i] = INT32_ZERO;
            }

            /* initializes state[N] with a seed */
            var _init_genrand = function (s) {
                var lt1812433253 = new Int32(1812433253);
                var j;
                state[0]= new Int32(s);
                for (j = 1; j < N; ++j) {
                    state[j] = ((lt1812433253.mul(state[j - 1].xor(state[j - 1].rshiftl(30)))).add(new Int32(j))); 
                    /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
                    /* In the previous versions, MSBs of the seed affect   */
                    /* only MSBs of the array state[].                        */
                    /* 2002/01/09 modified by Makoto Matsumoto             */
                    //state[j] &= 0xffffffff;  /* for >32 bit machines */
                }
                left = 1; initf = 1;
            };
            this.init_genrand = _init_genrand;

            /* initialize by an array with array-length */
            /* init_key is the array for initializing keys */
            /* key_length is its length */
            /* slight change for C++, 2004/2/26 */
            this.init_by_array = function (init_key, key_length) {
                var lt1664525 = new Int32(1664525);
                var lt1566083941 = new Int32(1566083941);
                var i, j, k;
                _init_genrand(19650218);
                i = 1; j = 0;
                k = (N > key_length ? N : key_length);
                for (; k; --k) {
                    state[i] = ((state[i].xor((state[i - 1].xor(state[i - 1].rshiftl(30))).mul(lt1664525))).add(
                    new Int32(init_key[j]))).add(new Int32(j)); /* non linear */
                    //state[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
                    i++; j++;
                    if (i >= N) { 
                        state[0] = state[N - 1];
                        i = 1; 
                    }
                    if (j >= key_length) {
                        j = 0; 
                    }
                }
                for (k = N - 1; k; --k) {
                    state[i] = (state[i].xor((state[i-1].xor(state[i - 1].rshiftl(30))).mul(lt1566083941))).sub(
                    new Int32(i)); /* non linear */
                    //state[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */
                    i++;
                    if (i >= N) {
                        state[0] = state[N - 1]; 
                        i = 1; 
                    }
                }

                state[0] = new Int32(0x80000000); /* MSB is 1; assuring non-zero initial array */ 
                left = 1; initf = 1;
            };

            var next_state = function () {
                var p = 0;
                var j;

                /* if init_genrand() has not been called, */
                /* a default initial seed is used         */
                if (initf == 0) {
                    _init_genrand(5489);
                }

                left = N;
                next = 0;
                
                for (j = N - M + 1; --j; ++p) {
                    state[p] = state[p + M].xor(TWIST(state[p], state[p + 1]));
                }
                
                for (j = M; --j; ++p) {
                    state[p] = state[p + M - N].xor(TWIST(state[p], state[p + 1]));
                }

                state[p] = state[p + M - N].xor(TWIST(state[p], state[0]));
            };

            var lt0x9d2c5680 = new Int32(0x9d2c5680);
            var lt0xefc60000 = new Int32(0xefc60000);

            /* generates a random number on [0,0xffffffff]-interval */
            var _genrand_int32 = function () {
                var y;

                if (--left == 0) {
                    next_state();
                }
                
                y = state[next];
                ++next;

                /* Tempering */
                y = y.xor(y.rshiftl(11));
                y = y.xor((y.lshift(7)).and(lt0x9d2c5680));
                y = y.xor((y.lshift(15)).and(lt0xefc60000));
                y = y.xor(y.rshiftl(18));

                return y.getValue();
            };
            this.genrand_int32 = _genrand_int32;

            /* generates a random number on [0,0x7fffffff]-interval */
            this.genrand_int31 = function () {
                var y;

                if (--left == 0) {
                    next_state();
                }
                y = state[next];
                ++next;

                /* Tempering */
                y = y.xor(y.rshiftl(11));
                y = y.xor((y.lshift(7)).and(lt0x9d2c5680));
                y = y.xor((y.lshift(15)).and(lt0xefc60000));
                y = y.xor(y.rshiftl(18));

                return (y.rshiftl(1)).getValue();
            };


            /* generates a random number on [0,1]-real-interval */
            this.genrand_real1 = function () {
                var y;

                if (--left == 0) {
                    next_state();
                }
                y = state[next];
                ++next;

                /* Tempering */
                y = y.xor(y.rshiftl(11));
                y = y.xor((y.lshift(7)).and(lt0x9d2c5680));
                y = y.xor((y.lshift(15)).and(lt0xefc60000));
                y = y.xor(y.rshiftl(18));

                return y.getValue() * (1.0/4294967295.0); 
                /* divided by 2^32-1 */ 
            };

            /* generates a random number on [0,1)-real-interval */
            this.genrand_real2 = function () {
                var y;

                if (--left == 0) {
                    next_state();
                }
                y = state[next];
                ++next;

                /* Tempering */
                y = y.xor(y.rshiftl(11));
                y = y.xor((y.lshift(7)).and(lt0x9d2c5680));
                y = y.xor((y.lshift(15)).and(lt0xefc60000));
                y = y.xor(y.rshiftl(18));

                return y.getValue() * (1.0 / 4294967296.0); 
                /* divided by 2^32 */
            };

            /* generates a random number on (0,1)-real-interval */
            this.genrand_real3 = function () {
                var y;

                if (--left == 0) {
                    next_state();
                }
                y = state[next];
                ++next;

                /* Tempering */
                y = y.xor(y.rshiftl(11));
                y = y.xor((y.lshift(7)).and(lt0x9d2c5680));
                y = y.xor((y.lshift(15)).and(lt0xefc60000));
                y = y.xor(y.rshiftl(18));

                return (y.getValue() + 0.5) * (1.0 / 4294967296.0); 
                /* divided by 2^32 */
            };

            /* generates a random number on [0,1) with 53-bit resolution*/
            this.genrand_res53 = function () {
                var a = ((new Int32(_genrand_int32())).rshiftl(5)).getValue();
                var b = ((new Int32(_genrand_int32())).rshiftl(6)).getValue(); 
                return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0); 
            };

        }

        function gen_rand_vector(seed, l, k, n){
            let generator = new MersenneTwister();
            generator.init_genrand(seed)
            let result = new Array();
            for (let i = 0; i < k; i++) {
                result[i] = new Array();
                for (let j = 0; j < n; j++) {
                    result[i][j] = generator.genrand_int32() % l;
                }
            }
            return result;
        } //сид, диапазон, количество нейронов, количество входов

        

        const delay = ms => new Promise(res => setTimeout(res, ms));

        let k = 8
        let n = 8
        let l = 100

        function start(websocketServerLocation){
            tpmSocket = new WebSocket(websocketServerLocation);

            let ClientTPM = new Machine()

            tpmSocket.onopen = (()=>{
                console.log("Connected to server")
                //ClientTPM = new Machine()
                tpmSocket.send(JSON.stringify({
                    'type': 'ClientReadySync',
                    'message': 'client connected',
                }));
                    // tpmSocket.send(JSON.stringify({
                    //     'type': 'join',
                    //     'channel': CHANNEL,
                    // }))
            })

            tpmSocket.onmessage = function(e){
                let data = JSON.parse(e.data)
                //console.log('Data:', data)
                if(data.type === 'chat'){
                    let messages = document.getElementById('messages')

                    messages.insertAdjacentHTML('beforeend', `<div>
                                                <p>${data.message}</p>
                                            </div>`)

                }
                if(data.type === 'receive_chaos_output2'){
                    console.log("receive_chaos_output2")
                    if (data.output == tpmclient.tpm.chaosmap()){
                        tpmclient.IsSync = True
                        console.log('SUCCESS: synched with Bob')
                        tpmSocket.CLOSED()
                        tpmclient.save_key()
                    }
                }
                if(data.type === 'ServerReadySync'){
                    console.log("ServerReadySync")
                    //console.log(`ServerReadySync msg:${data.message}`)
                    ClientTPM = new Machine(k, n, l)
                    tpmSocket.send(JSON.stringify({
                        'type': 'GetParametrs',
                        'message':'Give paremetrs of machine to server',
                        'k': ClientTPM.k,
                        'n': ClientTPM.n,
                        'l': ClientTPM.l
                    }));
                }
                if(data.type === 'GetFirstSeed'){
                    console.log("GetFirstSeed")
                    //console.log(`ServerReadySync msg:${data.message}`)
                    // console.log("seed:",data['seed'])
                    let X = gen_rand_vector(data['seed'], l, k, n)//data['vector']//gen_rand_vector(data['seed'], ClientTPM.l, ClientTPM.k, ClientTPM.n)
                    console.log(data['seed'],"-Vector:",X)
                    let resultClient = ClientTPM.get_output(X)
                    // console.log("resultClient:",resultClient)
                    // console.log("=================");
                    tpmSocket.send(JSON.stringify({
                        'type': 'GetResultClient',
                        'resultClient':resultClient,
                        'chaosmap': ClientTPM.chaosmap(),
                        'W': ClientTPM.W,
                        'X': X,
                    }));
                }
                if(data.type === 'GetSeedAndResultTrue'){
                    console.log("GetSeedAndResultTrue")
                    //console.log(ClientTPM)
                    let X = gen_rand_vector(data['seed'], l, k, n)// data['vector']//(data["seed"], l, k, n);
                    //console.log(ClientTPM.W)
                    console.log(data['seed'],"-Vector:",X)
                    //console.log(ClientTPM.chaosmap())
                    // setTimeout(() => {ClientTPM.update(data["Result"],X, 'hebbian'); }, 0);
                    ClientTPM.update(data["Result"],X, 'hebbian', data['W']);
                    let resultClient =  ClientTPM.get_output(X);
                        tpmSocket.send(JSON.stringify({
                            'type': 'GetResultClient',
                            'resultClient':resultClient,
                            'chaosmap': ClientTPM.chaosmap(),
                            'W': ClientTPM.W,
                            'X': X,
                    }));
                }
                if(data.type === 'GetSeedAndResultFalse'){
                    console.log("GetSeedAndResultFalse")
                    //console.log(`output_received msg:${data.message}`)
                    let X = gen_rand_vector(data['seed'], l, k, n)//data['vector']//gen_rand_vector(data["seed"], l, k, n);
                    let resultClient =  ClientTPM.get_output(X);
                    tpmSocket.send(JSON.stringify({
                        'type': 'GetResultClient',
                        'resultClient':resultClient,
                        'chaosmap': ClientTPM.chaosmap(),
                        'W': ClientTPM.W,
                        'X': X,
                    }));
                }
                if(data.type === 'FinishSync'){
                    console.log('FinishSync')
                    console.log(ClientTPM.W)
                    console.log(ClientTPM.chaosmap())
                    tpmSocket.close();
                }
                // if(data.type === 'Resync'){
                //     console.log('Reconnect');
                //     tpmSocket.send(JSON.stringify({
                //         'type': 'ClientReadySync',
                //         'message': 'client connected',
                //     }));
                // }
                // if(data.type === 'receive_chaos_output'){
                //     console.log(`receive_chaos_output msg:${data.message}`)
                //     tpmSocket.send(JSON.stringify({
                //         'type': 'confirm_chaos_output',
                //         'message':'sending chaos output',
                //         'output': tpmclient.tpm.chaosmap(),
                //     }));
                //     if (data.output == tpmclient.tpm.chaosmap()){
                //         tpmclient.IsSync = True;
                //         cosole.log('SUCCESS: synched with Alice');
                //         tpmSocket.disconnect();
                //     }
                // }
                // if(data.type === 'chat'){}
            }

            // ws.onmessage = function(evt) { alert('message received'); };
            tpmSocket.onclose = function(){
                // Try to reconnect in 5 seconds
                setTimeout(function(){start(websocketServerLocation)}, 35000);
            };
        }

        start(url)


        console.log('end')

    </script>
</body>
</html>
